import com.smarttrade.test.CoreTest;
//import com.smarttrade.test.MyJacocoPlugin;

buildscript {
    repositories {
        mavenLocal()
        jcenter()
      	//maven {
        //    url "https://plugins.gradle.org/m2/"
        //}
	}
	
	dependencies {
		//classpath 'com.smarttrade.builders:stdocplugin:4.0.0.0-CCHOTest'
		//classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.6.1"
		classpath group: 'org.sonarsource.scanner.gradle', name: 'sonarqube-gradle-plugin', version:'2.6.1'
	}
}

apply plugin: 'org.sonarqube'

sonarqube {
	properties {
		property "sonar.projectName", "cchoSonarProject1"
		property "sonar.projectKey", "cchoSonarKey1"
		property "sonar.host.url", "http://localhost:9000"
		property 'sonar.login', "admin"
		property 'sonar.password', "admin"
		property "sonar.jacoco.reportPaths", "${project.buildDir}/jacoco/jacocoMerge.exec"
		//property "sonar.junit.reportsPath", "${project.buildDir}/test-results/"
		property "sonar.exclusions", "**/src-generated/**/*"
		property "sonar.test.exclusions", "**/src-generated/**/*"
		property "sonar.coverage.exclusions", "**/src-generated/**"
		property "sonar.projectBaseDir", "$projectDir/.."
	}
}

afterEvaluate {
	println '@END: ' + project.name
}
allprojects {
	apply plugin: 'java'	
	apply plugin: 'maven-publish'
	apply plugin: 'groovy'
	apply plugin: 'jacoco'
	
	project.group = 'gradleDemo'
	project.version = '1.0.0.0'

	repositories {
		mavenLocal()
		jcenter()
	}
	
	afterEvaluate { project ->
		println '@EEE: ' + project.name
    }

}
import java.util.concurrent.Callable;

def ignoredCoverageProjects = ['']


subprojects {
	
	sourceSets{
		main {
			java {
				srcDirs += project.file("src-generated/main/java")
			}
			resources {
				srcDirs += project.file("src-generated/main/resources")
				srcDirs += project.file("src-generated/main/spec")
				srcDirs += project.file("src/main/spec")
			}
		}
		test {
			java {
				srcDirs += project.file("src-generated/test/java");
			}
			resources {
				srcDirs += project.file("src-generated/test/resources")
				srcDirs += project.file("src-generated/test/spec")
				srcDirs += project.file("src/test/spec")
			}
		}
	}
	
	println  "Root project:   "+ project.rootProject;
    println  "  rootDir:      "+ project.rootDir;
    println  "  projectDir:   "+ project.projectDir;
    println  "  buildDir:   "+ project.buildDir;
    println  "  project dir:  "+ System.getProperty("user.dir");
    
	println 'subprojects->begin: ' + project.name
	
	task testFF {
		println project.name + '@testFF'
	}
	
	tasks.whenTaskAdded { addedTask ->
		if(addedTask.name.startsWith('testF')) {
			project.afterEvaluate {
				println 'afterEvaluate@@' + project.name + ":" + addedTask.name
			}
		}
	}
		
	afterEvaluate { subproject ->
		println 'afterEvaluate@subprojects -> ' + subproject.name
	}
	
	publishing {
		publications {
	        mavenJava(MavenPublication) {
	            from components.java
	        }
		}
	}
	
	println 'subprojects->end: ' + project.name
	
	tasks.whenTaskAdded { addedTask ->
		println 'task added: ' + addedTask.name
	}
	
	afterEvaluate { project ->		
		def list = project.rootProject.tasks.sonarqube.dependsOn.find { depend ->	depend instanceof Callable<Iterable<? extends Task>>}
		list.each { depend ->
			project.rootProject.tasks.sonarqube.dependsOn.remove(depend)
		}
		
		project.rootProject.tasks.sonarqube.dependsOn compileJava
		
//		if(!project.name.equals('appender')) {
//			  project.sonarqube {
//				  skipProject = true
//			  }
//		} else {
//			project.rootProject.tasks.sonarqube.dependsOn project.tasks.testClasses
//		}

	}
	
	sonarqube {
		properties {
			//property "sonar.java.binaries","${project.buildDir}/classes/java"
			//property "sonar.sources","src/main/java"
		}
	}
	
	//sonar coverage exclusions
	project.ext.sonar_coverage_exclusions = ["**/src-generated/**"]
	project.ext.additional_sonar_coverage_exclusions = []
	
	if (ignoredCoverageProjects.contains(project.name)) {
		sonarqube {
			properties {
				property "sonar.coverage.exclusions", "**"
			}
		}
	} else {
		sonarqube {
			properties {
				property "sonar.coverage.exclusions", sonar_coverage_exclusions << additional_sonar_coverage_exclusions
			}
		}
	}
		
	jacocoTestReport {
   		group = "Reporting"
    	description = "Generates Jacoco coverage reports for unit tests"
    	executionData = fileTree("$buildDir/jacoco").matching  { 
			include "*.exec"
		}
    	
	    reports {
	        xml.enabled false
	        csv.enabled false
	        html.destination file("${buildDir}/jacocoHtml")
	    }
	}
}

task jacocoMerge (type: JacocoMerge) {
	executionData = files(subprojects.jacocoTestReport.executionData)
	println "@Exec: " + executionData.getFiles()
	destinationFile = file(project.getRootProject().getBuildDir().toString() + "/jacoco/jacocoMerge.exec")
}

task jacocoMerge1 (type: JacocoMerge) {
	executionData = files(subprojects.jacocoTestReport.executionData).filter {
		it.name.equals('testF.exec')
	}
	println "@Exec: " + executionData.getFiles()
	destinationFile = file(project.getRootProject().getBuildDir().toString() + "/jacoco/jacocoMerge1.exec")
}

task jacocoMerge2 (type: JacocoMerge) {
	executionData = files(subprojects.jacocoTestReport.executionData).filter {
		it.name.equals('testF1.exec')
	}
	println "@Exec: " + executionData.getFiles()
	destinationFile = file(project.getRootProject().getBuildDir().toString() + "/jacoco/jacocoMerge2.exec")
}

task jacocoMergex (type: JacocoMerge) {
	executionData = fileTree("$buildDir/jacoco").matching  { 
		include "*.exec"
		exclude "jacocoMerge.exec"
	}
	println "@Exec: " + executionData.getFiles()
	destinationFile = file("$buildDir/jacoco/jacocoMerge.exec")
}

task jacocoReport(type: org.gradle.testing.jacoco.tasks.JacocoReport) {
    //dependsOn = subprojects.test
	additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs).filter { !it.path.contains("src-generated") }
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs).filter { !it.path.contains("src-generated") }
    classDirectories =  files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        html.enabled = true
        xml.enabled = true
        csv.enabled = false
    }
}

publishing {
	publications {
        mavenJava(MavenPublication) {
            from components.java
        }
	}
}

dependencies {
    compile 'org.slf4j:slf4j-api:1.7.21'

    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-core:1.3'
}


println 'This is executed during the configuration phase.'

task configured {
    println 'configured>> This is also executed during the configuration phase.'
}

task test1 {
    doLast {
        println 'test1:doLast>> This is executed during the execution phase.'
    }
}

task testBoth {
    doFirst {
      println 'testBoth:doFirst>> This is executed first during the execution phase.'
    }
    doLast {
      println 'testBoth:doLast>> This is executed last during the execution phase.'
    }
    println 'testBoth>> This is executed during the configuration phase as well.'
}

task reportTestF(type: TestReport) {
	destinationDir = file("./junit_reports")
	
	subprojects.each { project ->
		project.fileTree('build/test-results/').matching  { 
			include "*/binary"
		}.visit {FileVisitDetails details ->
			if (details.file.isDirectory() && details.file.getName().equals('binary')) { 
    			reportOn details.file 
    		}
		}
	}
}

task taskX << {
    throw new GradleException('This task fails!');
}

task taskY << {
    if (taskX.state.failure != null) {
        //here is what shoud be executed if taskX fails
        println 'taskX was failed!'
    }
}

taskX.finalizedBy taskY

class GreetingPlugin implements Plugin<Project> {
    void apply(Project project) {
        def extension = project.extensions.create('greeting', GreetingPluginExtension, project)
        project.tasks.create('hello', Greeting) {
            message = extension.message
            outputFiles = extension.outputFiles
        }
    }
}

class GreetingPluginExtension {
    final PropertyState<String> message
    final ConfigurableFileCollection outputFiles

    GreetingPluginExtension(Project project) {
        message = project.property(String)
        message.set('Hello from GreetingPlugin')
        outputFiles = project.files()
    }

    void setOutputFiles(FileCollection outputFiles) {
        this.outputFiles.setFrom(outputFiles)
    }
    
    void setMessage(String message) {
        this.message.set(message)
    }
}

class Greeting extends DefaultTask {
    PropertyState<String> message = project.property(String)
    ConfigurableFileCollection outputFiles = project.files()

    @TaskAction
    void printMessage() {
        outputFiles.each {
            logger.quiet "Writing message 'Hi from Gradle' to file"
            it.text = message.get()
        }
    }
}

apply plugin: GreetingPlugin

greeting {
    message = 'Hi from Gradle'
    outputFiles = files('a.txt', 'b.txt')
}

allprojects {
	task cleanJacoco(type: Delete) {
	  delete "$buildDir/jacoco", "$buildDir/reports/jacoco"
	  followSymlinks = true
	}
}

def testedProjects = ['zzzTest1', 'zzzTest2']
def ignoredTestUFiles = [zzzTest1:['Test1bTestSuite1111.class'], zzzTest2:['Test2TestSuite1111.class']]

task test_unit_p(type: Test) {
	outputs.upToDateWhen { false }
	maxParallelForks = Runtime.runtime.availableProcessors() / 2
	println '@maxParallelForks: ' + maxParallelForks
	include '**/*TestSuite.class'
	
	subprojects.each { project ->
		if (testedProjects.contains('*') || testedProjects.contains(project.name)) {
			classpath += project.sourceSets.test.runtimeClasspath
			testClassesDirs += project.sourceSets.test.output.classesDirs
		} 
	}
	//classpath = files(subprojects.sourceSets.test.runtimeClasspath)
	//testClassesDirs = files(subprojects.sourceSets.test.output.classesDirs)
	
	//filter some tests
	subprojects.each { project ->
		if(ignoredTestUFiles.containsKey(project.name)) { 
			ignoredTestUFiles[project.name].each { exclude("**/$it") }
		}
	}
	
	/*
	subprojects.sourceSets.test.runtimeClasspath.each {
		println '@AAA: ' + it
		it.each { File file ->
			println file
		}
	}
	subprojects.sourceSets.main.output.classesDirs.each {
		println '@BBB: ' + it
		it.each { File file ->
			println file
		}
	}
	*/	
}

task test_unit
task test_functional

task reportTestU(type: TestReport) {
	destinationDir = file("$buildDir/junit_reports")
	
	subprojects.each { project ->
		reportOn project.file('build/test-results/testU/bin')
	}
}

subprojects {
	CoreTest testUTask = tasks.create('testU_' + project.name , CoreTest.class)
	testUTask.skipIfNoTestFound = false
	testUTask.classpath = sourceSets.test.runtimeClasspath
	testUTask.include('**/*TestSuite.class')
	
	if(ignoredTestUFiles.containsKey(project.name)) ignoredTestUFiles[project.name].each { testUTask.exclude("**/$it") }
	
	test.dependsOn testUTask
	
	testUTask.binResultsDir = project.file('build/test-results/testU/bin')
	test.enabled = false
	
	//-Dorg.gradle.debug=true
	//testUTask.jvmArgs '-Xdebug','-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=10999'
}

subprojects {
	project.rootProject.tasks.test_unit.dependsOn project.tasks.matching {it.name.startsWith('testU') }
	project.rootProject.tasks.test_functional.dependsOn project.tasks.matching {it.name.startsWith('testF') }
}